---
title: "DESeq2_spruce"
output: html_document
date: "2025-11-20"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = "~/projects/eco_genomics_2025/final_project/mydata")
```

Import the libraries that we're likely to need in this session
```{r message=FALSE, warning=FALSE}
library(DESeq2)
library(dplyr)
library(tidyr)
library(ggplot2)
library(scales)
library(ggpubr)
library(vsn)  
library("pheatmap")
library("vsn")
library(eulerr)
```

Import data:
```{r} 
# Import the counts table
countsTable <- read.csv("counts_matrix.csv", header=TRUE, row.names=1)

countsTableRound <- round(countsTable)
head(countsTableRound)

samples <- colnames(countsTableRound)
removeBLANK <- !grepl("BLANK", samples) # remove "BLANK_ACATTA from table"
countsTableRound <- countsTableRound[, removeBLANK]
samples <- colnames(countsTableRound)

# Import the metadata file
metadata_spruce <- read.csv("metadata_spruce.csv", header = TRUE, row.names=1)
```

Explore data distributions:
```{r}
colSums(countsTableRound)
mean(colSums(countsTableRound))
```

Visualizing variation across samples and genes:
```{r}
# variation across samples:
barplot(colSums(countsTableRound), names.arg=colnames(countsTableRound),cex.names=0.5, las=3,ylim=c(0,2500000))
abline(h=mean(colSums(countsTableRound)), col="blue", lwd=2)

# average number of counts per gene:
mean(rowSums(countsTableRound))
median(rowSums(countsTableRound))

# variation across genes:
apply(countsTableRound,2,mean) # 2 in apply, action across columns
apply(countsTableRound,1,mean) # 1 in apply, action across rows
hist(apply(countsTableRound,1,mean),xlim=c(0,6), ylim=c(0,60000),breaks=1000000)
```

Now we are going to start working with DESeq2!
```{r}
# subsetting to only include data from day 10
day10_samps = grep("_10_",colnames(countsTableRound))

# creating DESeq objects and defining the experimental design here with the tilda

dds <- DESeqDataSetFromMatrix(countData = countsTableRound[,day10_samps],
                              colData=metadata_spruce[which(metadata_spruce$day_harvest == 10),],
                              design= ~ source_climate + treatment + source_climate:treatment)

dim(dds)

# Filter out genes with too few reads by removing all genes with counts < 15
dds <- dds[rowSums(counts(dds) >= 15) >= 18,]
nrow(dds) 

# Run the DESeq model to test for differential gene expression
dds <- DESeq(dds)

# List the results you've generated
resultsNames(dds)

# Copy the results names 
```

```{r}
# Transformation to remove the dependence of the variance on the mean, particularly the high variance of the logarithm of count data when the mean is low."

# this gives log2(n + 1)
ntd <- normTransform(dds)
meanSdPlot(assay(ntd))

# Variance stabilizing transformation
vsd <- vst(dds, blind=FALSE)
meanSdPlot(assay(vsd))
```

Make a heatmap of the distance/dissimilarity of the samples:
```{r}
sampleDists <- dist(t(assay(vsd)))

library("RColorBrewer")
sampleDistMatrix <- as.matrix(sampleDists)
rownames(sampleDistMatrix) <- paste(vsd$treament, vsd$day_harvest, sep="-")
colnames(sampleDistMatrix) <- NULL
colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)
pheatmap(sampleDistMatrix,
         clustering_distance_rows=sampleDists,
         clustering_distance_cols=sampleDists,
         col=colors)

# Note any outliers
```

Making a cluster tree to look for outlier samples:
```{r}
sampleTree <- hclust(dist(sampleDists), method = "average")

# plot
plot(sampleTree, main="Sample clustering to detect outliers", sub="", xlab="",cex.lab=1.5, cex.axis=1.5, cex.main=2)

# is there a tree that we see on its own? We see two clusters but nothing particularly on its own
```

PCA to visualize global gene expression patterns:
```{r}
# first transform the data for plotting using variance stabilization
vsd <- vst(dds, blind=FALSE)

pcaData <- plotPCA(vsd, intgroup=c("treatment","source_climate"), returnData=TRUE)
percentVar <- round(100 * attr(pcaData,"percentVar"))

PCAglobal <- ggplot(pcaData, aes(PC1, PC2, color=treatment, shape=source_climate)) +
              geom_point(size=3) +
              xlab(paste0("PC1: ",percentVar[1],"% variance")) +
              ylab(paste0("PC2: ",percentVar[2],"% variance")) + 
              coord_fixed()

ggsave("PCAglobal.png", plot = PCAglobal, width = 7, height = 5, units = "in", dpi = 300)
```

```{r}
ggplot(pcaData, aes(PC1, PC2)) +
  geom_point(size=5, stroke = 1, aes(fill = source_climate, shape = treatment, alpha = day_harvest)) +
  xlab(paste0("PC1: ",percentVar[1],"% variance")) +
  ylab(paste0("PC2: ",percentVar[2],"% variance")) +
  scale_fill_manual(values=c('#6699CC',"#CC3333"), labels = c("Control", "Treatment"))+
  theme_linedraw() +
  theme(legend.position = "none") +
  theme(panel.border = element_rect(color = "black", fill = NA, size = 3))+
  theme(text = element_text(size = 20)) +
  theme(legend.title = element_blank()) +
  theme_linedraw()
```

There appears to be some clustering...!!!! But let's try specific contrasts just in case.
```{r}

metadata_spruce$day_harvest <- as.character(metadata_spruce$day_harvest)
dds$treatment <- relevel(dds$treatment, ref = "Control")
dds$source_climate <- relevel(dds$source_climate, ref = "CoolWet")

dds$group <- factor(paste0(dds$source_climate, dds$treatment))
design(dds) <- ~ group
dds <- DESeq(dds)
resultsNames(dds)
```

Comparing source_climate across the three different treatments:
```{r}
### Fix this part

#CoolWet_C_H_HD
#HotDry_C_H_HD

#Compare within source climate or do a pairwise comparison between CoolWet and HotDry.

#coolwet_DHvCont <- results(dds, contrast=c("group","CoolWetDrought; Heat","CoolWetControl"), alpha = 0.05)
#summary(coolwet_DHvCont)

#coolwet_HvCont <- results(dds, contrast=c("group","CoolWetHeat","CoolWetControl"), alpha = 0.05)
#summary(coolwet_HvCont)

#hotdry_Contvcoolwet_Cont <- results(dds, contrast=c("group","HotDryControl","CoolWetControl"), alpha = 0.05)
#summary(hotdry_Contvcoolwet_Cont)

#hotdry_DHvcoolwet_Cont <- results(dds, contrast=c("group","HotDryDrought; Heat","CoolWetControl"), alpha = 0.05)
#summary(hotdry_DHvcoolwet_Cont)

#hotdry_Hvcoolwet_Cont <- results(dds, contrast=c("group","HotDryDrought; Heat","CoolWetControl"), alpha = 0.05)
#summary(hotdry_Hvcoolwet_Cont)

```

Now we are making an MA plot:

- Question: What is the relationship between LFC and magnitude of expression?
```{r}
plotMA(coolwet_DHvCont, ylim=c(-5,5))
plotMA(coolwet_HvCont, ylim=c(-5,5))
plotMA(hotdry_Contvcoolwet_Cont, ylim=c(-5,5))
plotMA(hotdry_DHvcoolwet_Cont, ylim=c(-5,5))
plotMA(hotdry_Hvcoolwet_Cont, ylim=c(-5,5))

```

Making volcano plots:

- Question: What is the relationship between LFC and significance of DGE?

- First make it into a dataframe and remove NAs, add column to dataframe called "significance" and include adjust parameters showing "up" and "down" regulated genes. Then using ggplot with log fold change on the X axis and adjusted p-value on Y axis. Using the new column of significance to show up and downregulated genes, then giving lines to show log fold change and p-value.

```{r}

### coolwet_DHvCont volcano plot:

res_df <- as.data.frame(coolwet_DHvCont) # Make a dataframe
res_df <- res_df[!is.na(res_df$padj), ] # Remove NAs
res_df$significance <- "Not Sig" # Add significance column for color mapping
res_df$significance[res_df$padj < 0.05 & res_df$log2FoldChange > 0] <- "Up"
res_df$significance[res_df$padj < 0.05 & res_df$log2FoldChange < 0] <- "Down"

volcano_coolwet_DHvCont <- ggplot(res_df, aes(x = log2FoldChange, y = -log10(padj), color = significance)) +
  geom_point(alpha = 0.7, size = 2) +
  scale_color_manual(values = c("Up" = "blue", "Down" = "red", "Not Sig" = "grey")) +
  geom_vline(xintercept = c(-1, 1), linetype = "dashed", color = "black") +
  geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "black") +
  labs(
    title = "Volcano Plot: Coolwet - Drought; Heat vs Control",
    x = expression(log[2]~Fold~Change),
    y = expression(-log[10]~Adjusted~p~value)
  ) +
  theme_bw(base_size = 16) +
  theme(legend.title = element_blank())

volcano_coolwet_DHvCont


### coolwet_HvCont volcano plot:

res_df <- as.data.frame(coolwet_HvCont) # Make a dataframe
res_df <- res_df[!is.na(res_df$padj), ] # Remove NAs
res_df$significance <- "Not Sig" # Add significance column for color mapping
res_df$significance[res_df$padj < 0.05 & res_df$log2FoldChange > 0] <- "Up"
res_df$significance[res_df$padj < 0.05 & res_df$log2FoldChange < 0] <- "Down"

volcano_coolwet_HvCont <- ggplot(res_df, aes(x = log2FoldChange, y = -log10(padj), color = significance)) +
  geom_point(alpha = 0.7, size = 2) +
  scale_color_manual(values = c("Up" = "blue", "Down" = "red", "Not Sig" = "grey")) +
  geom_vline(xintercept = c(-1, 1), linetype = "dashed", color = "black") +
  geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "black") +
  labs(
    title = "Volcano Plot: Coolwet - Heat vs Control",
    x = expression(log[2]~Fold~Change),
    y = expression(-log[10]~Adjusted~p~value)
  ) +
  theme_bw(base_size = 16) +
  theme(legend.title = element_blank())

volcano_coolwet_HvCont

### hotdry_Contvcoolwet_Cont volcano plot:

res_df <- as.data.frame(hotdry_Contvcoolwet_Cont) # Make a dataframe
res_df <- res_df[!is.na(res_df$padj), ] # Remove NAs
res_df$significance <- "Not Sig" # Add significance column for color mapping
res_df$significance[res_df$padj < 0.05 & res_df$log2FoldChange > 0] <- "Up"
res_df$significance[res_df$padj < 0.05 & res_df$log2FoldChange < 0] <- "Down"

volcano_hotdry_Contvcoolwet_Cont <- ggplot(res_df, aes(x = log2FoldChange, y = -log10(padj), color = significance)) +
  geom_point(alpha = 0.7, size = 2) +
  scale_color_manual(values = c("Up" = "blue", "Down" = "red", "Not Sig" = "grey")) +
  geom_vline(xintercept = c(-1, 1), linetype = "dashed", color = "black") +
  geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "black") +
  labs(
    title = "Volcano Plot: HotDry - Control vs CoolWet - Control",
    x = expression(log[2]~Fold~Change),
    y = expression(-log[10]~Adjusted~p~value)
  ) +
  theme_bw(base_size = 16) +
  theme(legend.title = element_blank())

volcano_hotdry_Contvcoolwet_Cont

### hotdry_DHvcoolwet_Cont

res_df <- as.data.frame(hotdry_DHvcoolwet_Cont) # Make a dataframe
res_df <- res_df[!is.na(res_df$padj), ] # Remove NAs
res_df$significance <- "Not Sig" # Add significance column for color mapping
res_df$significance[res_df$padj < 0.05 & res_df$log2FoldChange > 0] <- "Up"
res_df$significance[res_df$padj < 0.05 & res_df$log2FoldChange < 0] <- "Down"

volcano_hotdry_DHvcoolwet_Cont <- ggplot(res_df, aes(x = log2FoldChange, y = -log10(padj), color = significance)) +
  geom_point(alpha = 0.7, size = 2) +
  scale_color_manual(values = c("Up" = "blue", "Down" = "red", "Not Sig" = "grey")) +
  geom_vline(xintercept = c(-1, 1), linetype = "dashed", color = "black") +
  geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "black") +
  labs(
    title = "Volcano Plot: HotDry - Drought; Heat vs CoolWet - Control",
    x = expression(log[2]~Fold~Change),
    y = expression(-log[10]~Adjusted~p~value)
  ) +
  theme_bw(base_size = 16) +
  theme(legend.title = element_blank())

volcano_hotdry_DHvcoolwet_Cont

ggsave("volcano_hotdry_DHvcoolwet_Cont.png", plot = volcano_hotdry_DHvcoolwet_Cont, width = 7, height = 5, units = "in", dpi = 300)
       
### hotdry_Hvcoolwet_Cont volcano plot:

res_df <- as.data.frame(hotdry_Hvcoolwet_Cont) # Make a dataframe
res_df <- res_df[!is.na(res_df$padj), ] # Remove NAs
res_df$significance <- "Not Sig" # Add significance column for color mapping
res_df$significance[res_df$padj < 0.05 & res_df$log2FoldChange > 0] <- "Up"
res_df$significance[res_df$padj < 0.05 & res_df$log2FoldChange < 0] <- "Down"

volcano_hotdry_Hvcoolwet_Cont <- ggplot(res_df, aes(x = log2FoldChange, y = -log10(padj), color = significance)) +
  geom_point(alpha = 0.7, size = 2) +
  scale_color_manual(values = c("Up" = "blue", "Down" = "red", "Not Sig" = "grey")) +
  geom_vline(xintercept = c(-1, 1), linetype = "dashed", color = "black") +
  geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "black") +
  labs(
    title = "Volcano Plot: HotDry - Heat vs CoolWet - Control",
    x = expression(log[2]~Fold~Change),
    y = expression(-log[10]~Adjusted~p~value)
  ) +
  theme_bw(base_size = 16) +
  theme(legend.title = element_blank())

volcano_hotdry_Hvcoolwet_Cont

```

Heatmap #1 - top 10 genes sorted by p-value:

- Question: For DEGs, what does gene expression variation look like across individual samples among treatment groups?

- In this heatmap, we are only pulling the top 100 genes, regardless of whether they are up or downregulated.
- Normalizing it by getting rid of top row of genes, making it into a dataframe, plotting it using a heatmap and don't want to cluster by columns.
```{r}
### top 10 genes for coolwet_DHvCont, anything more than 10 looked really squished on the heat map.
topgenes <- head(rownames(coolwet_DHvCont),10)
mat <- assay(vsd)[topgenes,]
mat <- mat - rowMeans(mat)
df <- as.data.frame(colData(dds)[,c("source_climate","treatment")])
pheatmap(mat, annotation_col=df)
pheatmap(mat, annotation_col=df, cluster_cols = F)

```

Make a heatmap of treatment significant genes and how they change across source_climate:

- Question: How does gene expression change across treatments compared to source climate?

- Start by identifying significant genes, then make a dataframe with log fold change for all of the significant genes from treatment types (we'll call this log fold change matrix), then remove rows with any same values, and use a heatmap to plot the dataframe and scale it by rows and then by color. Cluster by rows and colors by equal distance.

LFG of treatment and source climate:
- Heat map #1 for hotdry_Hvcoolwet_Cont:
```{r}
sig_genes_1 <- rownames(coolwet_DHvCont[which(coolwet_DHvCont$padj < 0.05 & !is.na(coolwet_DHvCont$padj)), ])

# Combine into a data frame
lfc_mat <- data.frame(
  coolwet_DHvCont = coolwet_DHvCont[sig_genes_1, "log2FoldChange"],
  coolwet_HvCont = coolwet_HvCont[sig_genes_1, "log2FoldChange"],
  hotdry_Contvcoolwet_Cont = hotdry_Contvcoolwet_Cont[sig_genes_1, "log2FoldChange"],
  hotdry_DHvcoolwet_Cont = hotdry_DHvcoolwet_Cont[sig_genes_1, "log2FoldChange"],
  hotdry_Hvcoolwet_Cont = hotdry_Hvcoolwet_Cont[sig_genes_1, "log2FoldChange"]

)

# Remove any rows with missing values (some genes may not be in all result tables)
lfc_mat <- na.omit(lfc_mat)

pheatmap(lfc_mat,
         scale = "row",             # scales each gene’s LFCs across generations
         color = colorRampPalette(c("blue", "white", "red"))(50),
         clustering_distance_rows = "euclidean",
         clustering_distance_cols = "euclidean",
         clustering_method = "complete",
         show_rownames = FALSE,
         main = "LFC of Sig Genes from CoolWet - Drought; Heat and CoolWet - Control")
```

- Heat map #2 for coolwet_HvCont:
```{r}
sig_genes_2 <- rownames(coolwet_HvCont[which(coolwet_HvCont$padj < 0.05 & !is.na(coolwet_HvCont$padj)), ])

# Combine into a data frame
lfc_mat_2 <- data.frame(
  coolwet_DHvCont = coolwet_DHvCont[sig_genes_2, "log2FoldChange"],
  coolwet_HvCont = coolwet_HvCont[sig_genes_2, "log2FoldChange"],
  hotdry_Contvcoolwet_Cont = hotdry_Contvcoolwet_Cont[sig_genes_2, "log2FoldChange"],
  hotdry_DHvcoolwet_Cont = hotdry_DHvcoolwet_Cont[sig_genes_2, "log2FoldChange"],
  hotdry_Hvcoolwet_Cont = hotdry_Hvcoolwet_Cont[sig_genes_2, "log2FoldChange"]

)

# Remove any rows with missing values (some genes may not be in all result tables)
lfc_mat_2 <- na.omit(lfc_mat_2)

pheatmap(lfc_mat_2,
         scale = "row",             # scales each gene’s LFCs across generations
         color = colorRampPalette(c("blue", "white", "red"))(50),
         clustering_distance_rows = "euclidean",
         clustering_distance_cols = "euclidean",
         clustering_method = "complete",
         show_rownames = FALSE,
         main = "LFC of Sig Genes from CoolWet - Heat and CoolWet - Control")
```
- Heat map #3 for hotdry_DHvcoolwet_Cont:
```{r}
sig_genes_3 <- rownames(hotdry_DHvcoolwet_Cont[which(hotdry_DHvcoolwet_Cont$padj < 0.05 & !is.na(hotdry_DHvcoolwet_Cont$padj)), ])

# Combine into a data frame
lfc_mat_3 <- data.frame(
  coolwet_DHvCont = coolwet_DHvCont[sig_genes_3, "log2FoldChange"],
  coolwet_HvCont = coolwet_HvCont[sig_genes_3, "log2FoldChange"],
  hotdry_Contvcoolwet_Cont = hotdry_Contvcoolwet_Cont[sig_genes_3, "log2FoldChange"],
  hotdry_DHvcoolwet_Cont = hotdry_DHvcoolwet_Cont[sig_genes_3, "log2FoldChange"],
  hotdry_Hvcoolwet_Cont = hotdry_Hvcoolwet_Cont[sig_genes_3, "log2FoldChange"]

)

# Remove any rows with missing values (some genes may not be in all result tables)
lfc_mat_3 <- na.omit(lfc_mat_3)

pheatmap(lfc_mat_3,
         scale = "row",             # scales each gene’s LFCs across generations
         color = colorRampPalette(c("blue", "white", "red"))(50),
         clustering_distance_rows = "euclidean",
         clustering_distance_cols = "euclidean",
         clustering_method = "complete",
         show_rownames = FALSE,
         main = "LFC of Sig Genes from HotDry - Drought; Heat and CoolWet - Control")
```

- Heat map #4 for hotdry_Hvcoolwet_Cont:
```{r}
sig_genes_4 <- rownames(hotdry_Hvcoolwet_Cont[which(hotdry_Hvcoolwet_Cont$padj < 0.05 & !is.na(hotdry_Hvcoolwet_Cont$padj)), ])

# Combine into a data frame
lfc_mat_4 <- data.frame(
  coolwet_DHvCont = coolwet_DHvCont[sig_genes_4, "log2FoldChange"],
  coolwet_HvCont = coolwet_HvCont[sig_genes_4, "log2FoldChange"],
  hotdry_Contvcoolwet_Cont = hotdry_Contvcoolwet_Cont[sig_genes_4, "log2FoldChange"],
  hotdry_DHvcoolwet_Cont = hotdry_DHvcoolwet_Cont[sig_genes_4, "log2FoldChange"],
  hotdry_Hvcoolwet_Cont = hotdry_Hvcoolwet_Cont[sig_genes_4, "log2FoldChange"]

)

# Remove any rows with missing values (some genes may not be in all result tables)
lfc_mat_4 <- na.omit(lfc_mat_4)

pheatmap(lfc_mat_4,
         scale = "row",             # scales each gene’s LFCs across generations
         color = colorRampPalette(c("blue", "white", "red"))(50),
         clustering_distance_rows = "euclidean",
         clustering_distance_cols = "euclidean",
         clustering_method = "complete",
         show_rownames = FALSE,
         main = "LFC of Sig Genes from HotDry - Heat (treatment) and CoolWet - Control")
```
DESeq2 To TopGO:
```{r}
library(topGO)
library(GO.db)

# Convert to data frame
coolwet_DHvCont_df <- as.data.frame(coolwet_DHvCont)

# Add geneID column from rownames
coolwet_DHvCont_df$geneID <- rownames(coolwet_DHvCont)
coolwet_DHvCont_df <- coolwet_DHvCont_df[, c("geneID", setdiff(names(coolwet_DHvCont_df), "geneID"))]

# Read GO terms file () provided in 
spruce_go <- read.delim("Pmariana_GOannot.tsv", header = TRUE) %>%
  slice(-c(1,2)) %>%  # remove header rows if present
  na.omit()  # remove missing GO annotations

# Identify DEGs that have GO annotations
coolwet_DHvCont_go <- coolwet_DHvCont_df[coolwet_DHvCont_df$geneID %in% spruce_go$geneID, ]

# Keep only significant DEGs 
coolwet_DHvCont_GO_sig <- subset(coolwet_DHvCont_go, padj < 0.05 & abs(log2FoldChange) > 1)

# Merge with GO annotations
coolwet_DHvCont_stat <- merge(coolwet_DHvCont_GO_sig, spruce_go, by = "geneID")

# Create gene2GO list which is used in the topgo function 
treatment1GO <- spruce_go %>%
  filter(!is.na(GO) & GO != "") %>%
  group_by(geneID) %>%
  summarise(GO = list(unique(GO)), .groups = "drop") %>%
  with(setNames(GO, geneID))

# Split semicolon-separated GO terms
genes2GO_1 <- lapply(treatment1GO, function(x) unlist(strsplit(x, ";")))

# Create geneList for TopGO: 1 = DEG, 0 = not DEG
all_genes <- names(genes2GO_1)
geneList <- setNames(as.integer(all_genes %in% coolwet_DHvCont_stat$geneID), all_genes)

#Build TopGO pipeline 
GOdata <- new("TopGOdata",
              description = "CoolWet: Drought; Heat vs. Control DEGs GO enrichment",
              ontology = "BP",
              allGenes = geneList,
              geneSel = function(x) x == 1,
              nodeSize = 5,
              annot = annFUN.genes2GO_1,
              genes2GO_1 = genes2GO_1)

#test for enrichment 
result <- runTest(coolwet_DHvCont_stat_GOdata, algorithm = "parentChild", statistic = "fisher")

# Convert results to table
res_table <- GenTable(coolwet_DHvCont_stat_GOdata, classicFisher = result,
                      topNodes = length(usedGO(coolwet_DHvCont_stat_GOdata))) %>%
  mutate(classicFisher = as.numeric(classicFisher),
         Annotated = as.numeric(Annotated),
         Significant = as.numeric(Significant))

#plot!

# Keep GO terms with enough but not too many genes
filtered_GO_results <- res_table %>%
  filter(Annotated >= 5 & Annotated < 500) %>%  # adjust as needed
  group_by(Term) %>%
  slice_min(classicFisher, n = 1) %>%  # keep only the most significant per Term
  ungroup() %>%
  arrange(classicFisher)


coolwet_DHvCont_TopGO_plot <- function(df, title) {
  df %>%
    slice_head(n = 30) %>%
    ggplot(aes(x = -log10(classicFisher),
               y = reorder(Term, -log10(classicFisher)),
               size = Significant,
               color = -log10(classicFisher))) +
    geom_point(alpha = 0.8) +
    scale_color_gradientn(
      colors = c("pink", "orchid", "purple", "purple4"),
      name = "-log10(p-value)"
    ) +
    scale_size_continuous(name = "# Significant Genes") +
    xlab("-log10-classicFisher") +
    ylab("Biological Function") +
    ggtitle(title) +
    theme_minimal() +
    theme(plot.margin = margin(10, 100, 10, 10),
          axis.text.y = element_text(size = 10, hjust = 1)) +
    coord_cartesian(clip = "off")
}

# Generate plot
coolwet_DHvCont_topGO_plot <- TopGO_plot(filtered_GO_results, "GO Enrichment for DEGs at Day 10: CoolWet - Drought; Heat vs. Control")
coolwet_DHvCont_topGO_plot
```

```{r}
library(topGO)
library(GO.db)

z <- read.table("/gpfs1/cl/ecogen/pbio6800/PopulationGenomics/ref_genome/Pmariana/annotation/GO_annotations/Pmariana_GO_annotations_sorted_join.txt", header=F, fill=T)

z$geneID <- gsub('ID=', '', z$geneID)
z_subset <- z %>% select(gene, geneID)

# Convert to data frame
coolwet_HvCont_df <- as.data.frame(coolwet_HvCont)

# Add geneID column from rownames
coolwet_HvCont_df$geneID <- rownames(coolwet_HvCont)
coolwet_HvCont_df <- coolwet_HvCont_df[, c("geneID", setdiff(names(coolwet_HvCont_df), "geneID"))]

# Read GO terms file () provided in 
spruce_go <- read.delim("Pmariana_GOannot.tsv", header = TRUE) %>%
  slice(-c(1,2)) %>%  # remove header rows if present
  na.omit()  # remove missing GO annotations

x <- merge(coolwet_HvCont_df, z_subset, by="geneID")

# Identify DEGs that have GO annotations
coolwet_HvCont_go <- x[x$geneID %in% coolwet_HvCont_df$geneID, ]

# Keep only significant DEGs 
coolwet_HvCont_GO_sig <- subset(coolwet_HvCont_go, padj < 0.05 & abs(log2FoldChange) > 1)

# Merge with GO annotations
coolwet_HvCont_stat <- merge(coolwet_HvCont_GO_sig, coolwet_HvCont_go, by = "geneID")

# Create gene2GO list which is used in the topgo function 
treatment1GO <- coolwet_HvCont_stat %>%
  filter(!is.na(GO) & GO != "") %>%
  group_by(geneID) %>%
  summarise(GO = list(unique(GO)), .groups = "drop") %>%
  with(setNames(GO, geneID))

# Split semicolon-separated GO terms
genes2GO_1 <- lapply(treatment1GO, function(x) unlist(strsplit(x, ";")))

# Create geneList for TopGO: 1 = DEG, 0 = not DEG
all_genes <- names(genes2GO_1)
geneList <- setNames(as.integer(all_genes %in% coolwet_DHvCont_stat$geneID), all_genes)

#Build TopGO pipeline 
GOdata <- new("TopGOdata",
              description = "CoolWet: Drought; Heat vs. Control DEGs GO enrichment",
              ontology = "BP",
              allGenes = geneList,
              geneSel = function(x) x == 1,
              nodeSize = 5,
              annot = annFUN.genes2GO_1,
              genes2GO_1 = genes2GO_1)

#test for enrichment 
result <- runTest(coolwet_DHvCont_stat_GOdata, algorithm = "parentChild", statistic = "fisher")

# Convert results to table
res_table <- GenTable(coolwet_DHvCont_stat_GOdata, classicFisher = result,
                      topNodes = length(usedGO(coolwet_DHvCont_stat_GOdata))) %>%
  mutate(classicFisher = as.numeric(classicFisher),
         Annotated = as.numeric(Annotated),
         Significant = as.numeric(Significant))

#plot!

# Keep GO terms with enough but not too many genes
filtered_GO_results <- res_table %>%
  filter(Annotated >= 5 & Annotated < 500) %>%  # adjust as needed
  group_by(Term) %>%
  slice_min(classicFisher, n = 1) %>%  # keep only the most significant per Term
  ungroup() %>%
  arrange(classicFisher)


coolwet_DHvCont_TopGO_plot <- function(df, title) {
  df %>%
    slice_head(n = 30) %>%
    ggplot(aes(x = -log10(classicFisher),
               y = reorder(Term, -log10(classicFisher)),
               size = Significant,
               color = -log10(classicFisher))) +
    geom_point(alpha = 0.8) +
    scale_color_gradientn(
      colors = c("pink", "orchid", "purple", "purple4"),
      name = "-log10(p-value)"
    ) +
    scale_size_continuous(name = "# Significant Genes") +
    xlab("-log10-classicFisher") +
    ylab("Biological Function") +
    ggtitle(title) +
    theme_minimal() +
    theme(plot.margin = margin(10, 100, 10, 10),
          axis.text.y = element_text(size = 10, hjust = 1)) +
    coord_cartesian(clip = "off")
}

# Generate plot
coolwet_DHvCont_topGO_plot <- TopGO_plot(filtered_GO_results, "GO Enrichment for DEGs at Day 10: CoolWet - Drought; Heat vs. Control")
coolwet_DHvCont_topGO_plot
```