---
title: "Homework 2"
author: "Rei Jia"
date: "2025-11-05"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = "~/projects/eco_genomics_2025/transcriptomics/mydata")
```

Import libraries:
```{r message=FALSE, warning=FALSE}
library(DESeq2)
library(dplyr)
library(tibble)
library(topGO)
library(GO.db)
library(ggplot2)
library(scales)
library(gridExtra)
```

Import the counts matrix:
```{r}
countsTable <- read.table("counts_table.txt", header=TRUE, row.names=1)
dim(countsTable)

countsTableRound <- round(countsTable) # bc DESeq2 doesn't like decimals (and Salmon outputs data with decimals)
# Corrects the column names to match between the metadata table and the counts matrix.
colnames(countsTableRound) <- substr(colnames(countsTableRound), start=1, stop = 4)
```

Import the sample description table and create DESeq object:
```{r}
conds <- read.delim("metadata.txt", header=TRUE, stringsAsFactors = TRUE, row.names=1)

# Define the experimental design here with the tilda

dds <- DESeqDataSetFromMatrix(countData = countsTableRound, colData=conds, 
                              design= ~ generation + line)

dim(dds)
```

```{r}
# Filter out genes with too few reads - remove all genes with counts < 15 in more than 75% of 24 samples, so 18)
## suggested by WGCNA on RNAseq FAQ

dds <- dds[rowSums(counts(dds) >= 15) >= 18,]
nrow(dds) 
# How many transcripts have at least 15 reads (a.k.a counts) in 75% of the samples

# Run the DESeq model to test for differential gene expression

dds$line <- relevel(dds$line, ref = "control")
dds$generation <- relevel(dds$generation, ref = "G1")

dds$group <- factor(paste0(dds$line, dds$generation))
design(dds) <- ~ group
dds <- DESeq(dds)
resultsNames(dds)


#Gen1
resG1_CvT <- results(dds, contrast=c("group","controlG1","treatmentG1"), alpha = 0.05)
resG1_CvT <- resG1_CvT[order(resG1_CvT$padj),] #sort
resG1_CvT <- resG1_CvT[!is.na(resG1_CvT$padj),]

#Gen2
resG2_CvT <- results(dds, contrast=c("group","controlG2","treatmentG2"), alpha = 0.05)
resG2_CvT <- resG2_CvT[order(resG2_CvT$padj),] #sort
resG2_CvT <- resG2_CvT[!is.na(resG2_CvT$padj),]

#Gen3
resG3_CvT <- results(dds, contrast=c("group","controlG3","treatmentG3"), alpha = 0.05)
resG3_CvT <- resG3_CvT[order(resG3_CvT$padj),] #sort
resG3_CvT <- resG3_CvT[!is.na(resG3_CvT$padj),]

#Gen4
resG4_CvT <- results(dds, contrast=c("group","controlG4","treatmentG4"), alpha = 0.05)
resG4_CvT <- resG4_CvT[order(resG4_CvT$padj),] #sort
resG4_CvT <- resG4_CvT[!is.na(resG4_CvT$padj),]
```

Run groups from each generation to TopGO!
```{r}
#### Generation 1:

# Convert to data frame
res_G1_df <- as.data.frame(resG1_CvT)

# Add geneID column from rownames
res_G1_df$geneID <- rownames(res_G1_df)
res_G1_df <- res_G1_df[, c("geneID", setdiff(names(res_G1_df), "geneID"))]

# Read GO terms file (tonsa_go) provided in 
tonsa_go <- read.delim("Genes_GO_terms_output.tsv", header = TRUE) %>%
  slice(-c(1,2)) %>%  # remove header rows if present
  na.omit()  # remove missing GO annotations

# Identify DEGs that have GO annotations
res_G1_GO <- res_G1_df[res_G1_df$geneID %in% tonsa_go$geneID, ]

# Identify only significant DEGs - this will be used later on in the next step.
res_G1_GO_sig <- subset(res_G1_GO, padj < 0.05 & abs(log2FoldChange) > 1)

# Merge with GO annotations
Gen1_tonsa_stat <- merge(res_G1_GO_sig, tonsa_go, by = "geneID")

# Create gene2GO list which is used in the topgo function 
gene2GO <- tonsa_go %>%
  filter(!is.na(GO) & GO != "") %>%
  group_by(geneID) %>%
  summarise(GO = list(unique(GO)), .groups = "drop") %>%
  with(setNames(GO, geneID))

# Split semicolon-separated GO terms
gene2GO <- lapply(gene2GO, function(x) unlist(strsplit(x, ";")))

# Create geneList for TopGO: 1 = DEG, 0 = not DEG
all_genes <- names(gene2GO)
geneList <- setNames(as.integer(all_genes %in% Gen1_tonsa_stat$geneID), all_genes)

#Build TopGO pipeline 
GOdata <- new("topGOdata",
              description = "G1 DEGs GO enrichment",
              ontology = "BP",
              allGenes = geneList,
              geneSel = function(x) x == 1,
              nodeSize = 5,
              annot = annFUN.gene2GO,
              gene2GO = gene2GO)

#test for enrichment 
result <- runTest(GOdata, algorithm = "parentChild", statistic = "fisher")

# Convert results to table
Gen1_res_table <- GenTable(GOdata, classicFisher = result,
                      topNodes = length(usedGO(GOdata))) %>%
  mutate(classicFisher = as.numeric(classicFisher),
         Annotated = as.numeric(Annotated),
         Significant = as.numeric(Significant))

#Plot the filtered results, showing >5 and < 500 gene members.

# Keep GO terms with enough but not too many genes
filtered_GO_results_G1 <- Gen1_res_table %>%
  filter(Annotated >= 5 & Annotated < 500) %>%  # adjust as needed
  group_by(Term) %>%
  slice_min(classicFisher, n = 1) %>%  # keep only the most significant per Term
  ungroup() %>%
  arrange(classicFisher)


G1_TopGO_plot <- function(df, title) {
  df %>%
    slice_head(n = 30) %>%
    ggplot(aes(x = -log10(classicFisher),
               y = reorder(Term, -log10(classicFisher)),
               size = Significant,
               color = -log10(classicFisher))) +
    geom_point(alpha = 0.8) +
    scale_color_gradientn(
      colors = c("pink", "orchid", "purple", "purple4"),
      name = "-log10(p-value)"
    ) +
    scale_size_continuous(name = "# Significant Genes") +
    xlab("-log10-classicFisher") +
    ylab("Biological Function") +
    ggtitle(title) +
    theme_minimal() +
    theme(plot.margin = margin(10, 100, 10, 10),
          axis.text.y = element_text(size = 10, hjust = 1)) +
    coord_cartesian(clip = "off")
}

# Generate G1 plot
G1_topGO_plot <- G1_TopGO_plot(filtered_GO_results_G1, "GO Enrichment for DEGs at Gen1")
G1_topGO_plot

#### Generation 2:

# Convert to data frame
res_G2_df <- as.data.frame(resG2_CvT)

# Add geneID column from rownames
res_G2_df$geneID <- rownames(res_G2_df)
res_G2_df <- res_G2_df[, c("geneID", setdiff(names(res_G2_df), "geneID"))]

# Read GO terms file (tonsa_go) provided in 
tonsa_go <- read.delim("Genes_GO_terms_output.tsv", header = TRUE) %>%
  slice(-c(1,2)) %>%  # remove header rows if present
  na.omit()  # remove missing GO annotations

# Identify DEGs that have GO annotations
res_G2_GO <- res_G2_df[res_G2_df$geneID %in% tonsa_go$geneID, ]

# Identify only significant DEGs - this will be used later on in the next step.
res_G2_GO_sig <- subset(res_G2_GO, padj < 0.05 & abs(log2FoldChange) > 1)

# Merge with GO annotations
Gen2_tonsa_stat <- merge(res_G2_GO_sig, tonsa_go, by = "geneID")

# Create gene2GO list which is used in the topgo function 
gene2GO <- tonsa_go %>%
  filter(!is.na(GO) & GO != "") %>%
  group_by(geneID) %>%
  summarise(GO = list(unique(GO)), .groups = "drop") %>%
  with(setNames(GO, geneID))

# Split semicolon-separated GO terms
gene2GO <- lapply(gene2GO, function(x) unlist(strsplit(x, ";")))

# Create geneList for TopGO: 1 = DEG, 0 = not DEG
all_genes <- names(gene2GO)
geneList <- setNames(as.integer(all_genes %in% Gen2_tonsa_stat$geneID), all_genes)

#Build TopGO pipeline 
GOdata <- new("topGOdata",
              description = "G2 DEGs GO enrichment",
              ontology = "BP",
              allGenes = geneList,
              geneSel = function(x) x == 1,
              nodeSize = 5,
              annot = annFUN.gene2GO,
              gene2GO = gene2GO)

#test for enrichment 
result <- runTest(GOdata, algorithm = "parentChild", statistic = "fisher")

# Convert results to table
Gen2_res_table <- GenTable(GOdata, classicFisher = result,
                      topNodes = length(usedGO(GOdata))) %>%
  mutate(classicFisher = as.numeric(classicFisher),
         Annotated = as.numeric(Annotated),
         Significant = as.numeric(Significant))

#Plot the filtered results, showing >5 and < 500 gene members.

# Keep GO terms with enough but not too many genes
filtered_GO_results_G2 <- Gen2_res_table %>%
  filter(Annotated >= 5 & Annotated < 500) %>%  # adjust as needed
  group_by(Term) %>%
  slice_min(classicFisher, n = 1) %>%  # keep only the most significant per Term
  ungroup() %>%
  arrange(classicFisher)


G2_TopGO_plot <- function(df, title) {
  df %>%
    slice_head(n = 30) %>%
    ggplot(aes(x = -log10(classicFisher),
               y = reorder(Term, -log10(classicFisher)),
               size = Significant,
               color = -log10(classicFisher))) +
    geom_point(alpha = 0.8) +
    scale_color_gradientn(
      colors = c("lightblue", "cornflowerblue", "blue1", "midnightblue"),
      name = "-log10(p-value)"
    ) +
    scale_size_continuous(name = "# Significant Genes") +
    xlab("-log10-classicFisher") +
    ylab("Biological Function") +
    ggtitle(title) +
    theme_minimal() +
    theme(plot.margin = margin(10, 100, 10, 10),
          axis.text.y = element_text(size = 10, hjust = 1)) +
    coord_cartesian(clip = "off")
}

# Generate G2 plot
G2_topGO_plot <- G2_TopGO_plot(filtered_GO_results_G2, "GO Enrichment for DEGs at Gen2")
G2_topGO_plot

#### Generation 3:

# Convert to data frame
res_G3_df <- as.data.frame(resG3_CvT)

# Add geneID column from rownames
res_G3_df$geneID <- rownames(res_G3_df)
res_G3_df <- res_G3_df[, c("geneID", setdiff(names(res_G3_df), "geneID"))]

# Read GO terms file (tonsa_go) provided in 
tonsa_go <- read.delim("Genes_GO_terms_output.tsv", header = TRUE) %>%
  slice(-c(1,2)) %>%  # remove header rows if present
  na.omit()  # remove missing GO annotations

# Identify DEGs that have GO annotations
res_G3_GO <- res_G3_df[res_G3_df$geneID %in% tonsa_go$geneID, ]

# Identify only significant DEGs - this will be used later on in the next step.
res_G3_GO_sig <- subset(res_G3_GO, padj < 0.05 & abs(log2FoldChange) > 1)

# Merge with GO annotations
Gen3_tonsa_stat <- merge(res_G3_GO_sig, tonsa_go, by = "geneID")

# Create gene2GO list which is used in the topgo function 
gene2GO <- tonsa_go %>%
  filter(!is.na(GO) & GO != "") %>%
  group_by(geneID) %>%
  summarise(GO = list(unique(GO)), .groups = "drop") %>%
  with(setNames(GO, geneID))

# Split semicolon-separated GO terms
gene2GO <- lapply(gene2GO, function(x) unlist(strsplit(x, ";")))

# Create geneList for TopGO: 1 = DEG, 0 = not DEG
all_genes <- names(gene2GO)
geneList <- setNames(as.integer(all_genes %in% Gen3_tonsa_stat$geneID), all_genes)

#Build TopGO pipeline 
GOdata <- new("topGOdata",
              description = "G3 DEGs GO enrichment",
              ontology = "BP",
              allGenes = geneList,
              geneSel = function(x) x == 1,
              nodeSize = 5,
              annot = annFUN.gene2GO,
              gene2GO = gene2GO)

#test for enrichment 
result <- runTest(GOdata, algorithm = "parentChild", statistic = "fisher")

# Convert results to table
Gen3_res_table <- GenTable(GOdata, classicFisher = result,
                      topNodes = length(usedGO(GOdata))) %>%
  mutate(classicFisher = as.numeric(classicFisher),
         Annotated = as.numeric(Annotated),
         Significant = as.numeric(Significant))

#Plot the filtered results, showing >5 and < 500 gene members.

# Keep GO terms with enough but not too many genes
filtered_GO_results_G3 <- Gen3_res_table %>%
  filter(Annotated >= 5 & Annotated < 500) %>%  # adjust as needed
  group_by(Term) %>%
  slice_min(classicFisher, n = 1) %>%  # keep only the most significant per Term
  ungroup() %>%
  arrange(classicFisher)


G3_TopGO_plot <- function(df, title) {
  df %>%
    slice_head(n = 30) %>%
    ggplot(aes(x = -log10(classicFisher),
               y = reorder(Term, -log10(classicFisher)),
               size = Significant,
               color = -log10(classicFisher))) +
    geom_point(alpha = 0.8) +
    scale_color_gradientn(
      colors = c("rosybrown1", "rosybrown3", "tomato3", "hotpink4", "deeppink4"),
      name = "-log10(p-value)"
    ) +
    scale_size_continuous(name = "# Significant Genes") +
    xlab("-log10-classicFisher") +
    ylab("Biological Function") +
    ggtitle(title) +
    theme_minimal() +
    theme(plot.margin = margin(10, 100, 10, 10),
          axis.text.y = element_text(size = 10, hjust = 1)) +
    coord_cartesian(clip = "off")
}

# Generate G3 plot
G3_topGO_plot <- G3_TopGO_plot(filtered_GO_results_G3, "GO Enrichment for DEGs at Gen3")
G3_topGO_plot

#### Generation 4:

# Convert to data frame
res_G4_df <- as.data.frame(resG4_CvT)

# Add geneID column from rownames
res_G4_df$geneID <- rownames(res_G4_df)
res_G4_df <- res_G4_df[, c("geneID", setdiff(names(res_G4_df), "geneID"))]

# Read GO terms file (tonsa_go) provided in 
tonsa_go <- read.delim("Genes_GO_terms_output.tsv", header = TRUE) %>%
  slice(-c(1,2)) %>%  # remove header rows if present
  na.omit()  # remove missing GO annotations

# Identify DEGs that have GO annotations
res_G4_GO <- res_G4_df[res_G4_df$geneID %in% tonsa_go$geneID, ]

# Identify only significant DEGs - this will be used later on in the next step.
res_G4_GO_sig <- subset(res_G4_GO, padj < 0.05 & abs(log2FoldChange) > 1)

# Merge with GO annotations
Gen4_tonsa_stat <- merge(res_G4_GO_sig, tonsa_go, by = "geneID")

# Create gene2GO list which is used in the topgo function 
gene2GO <- tonsa_go %>%
  filter(!is.na(GO) & GO != "") %>%
  group_by(geneID) %>%
  summarise(GO = list(unique(GO)), .groups = "drop") %>%
  with(setNames(GO, geneID))

# Split semicolon-separated GO terms
gene2GO <- lapply(gene2GO, function(x) unlist(strsplit(x, ";")))

# Create geneList for TopGO: 1 = DEG, 0 = not DEG
all_genes <- names(gene2GO)
geneList <- setNames(as.integer(all_genes %in% Gen4_tonsa_stat$geneID), all_genes)

#Build TopGO pipeline 
GOdata <- new("topGOdata",
              description = "G4 DEGs GO enrichment",
              ontology = "BP",
              allGenes = geneList,
              geneSel = function(x) x == 1,
              nodeSize = 5,
              annot = annFUN.gene2GO,
              gene2GO = gene2GO)

#test for enrichment 
result <- runTest(GOdata, algorithm = "parentChild", statistic = "fisher")

# Convert results to table
Gen4_res_table <- GenTable(GOdata, classicFisher = result,
                      topNodes = length(usedGO(GOdata))) %>%
  mutate(classicFisher = as.numeric(classicFisher),
         Annotated = as.numeric(Annotated),
         Significant = as.numeric(Significant))

#Plot the filtered results, showing >5 and < 500 gene members.

# Keep GO terms with enough but not too many genes
filtered_GO_results_G4 <- Gen4_res_table %>%
  filter(Annotated >= 5 & Annotated < 500) %>%  # adjust as needed
  group_by(Term) %>%
  slice_min(classicFisher, n = 1) %>%  # keep only the most significant per Term
  ungroup() %>%
  arrange(classicFisher)


G4_TopGO_plot <- function(df, title) {
  df %>%
    slice_head(n = 30) %>%
    ggplot(aes(x = -log10(classicFisher),
               y = reorder(Term, -log10(classicFisher)),
               size = Significant,
               color = -log10(classicFisher))) +
    geom_point(alpha = 0.8) +
    scale_color_gradientn(
      colors = c("lightgreen", "darkseagreen3", "yellowgreen", "springgreen4", "darkgreen"),
      name = "-log10(p-value)"
    ) +
    scale_size_continuous(name = "# Significant Genes") +
    xlab("-log10-classicFisher") +
    ylab("Biological Function") +
    ggtitle(title) +
    theme_minimal() +
    theme(plot.margin = margin(10, 100, 10, 10),
          axis.text.y = element_text(size = 10, hjust = 1)) +
    coord_cartesian(clip = "off")
}

# Generate G4 plot
G4_topGO_plot <- G4_TopGO_plot(filtered_GO_results_G4, "GO Enrichment for DEGs at Gen4")
G4_topGO_plot
```
Saving each plot into a single .png file:
```{r}
# Saving "GO Enrichment DEGs by Generation" plots
plot <- list(G1_topGO_plot + G2_topGO_plot + G3_topGO_plot + G4_topGO_plot)
ggsave("GOEnrichmentG1toG4.png", plot = plot, width=20, height=10, units = "in", dpi = 300)
```

Generating ID lists for Generations 1 through 4 to be input into REViGO:
```{r}
## Generate Gen1 ID list for REViGO ###

# Select only the columns REVIGO needs
revigo_input_G1 <- filtered_GO_results_G1[, c("GO.ID", "classicFisher")]

sigRes_G1 <- revigo_input_G1[as.numeric(revigo_input_G1$classicFisher) < 0.05, ]

# Rename columns for clarity
colnames(sigRes_G1) <- c("GO.ID", "pValue")

# Save as txt to upload to REVIGO
write.table(sigRes_G1, file = "G1topGOsig_for_REVIGO.txt", sep = "\t", row.names = FALSE, quote = FALSE)

### Generate Gen2 ID list for REViGO ###

# Select only the columns REVIGO needs
revigo_input_G2 <- filtered_GO_results_G2[, c("GO.ID", "classicFisher")]

sigRes_G2 <- revigo_input_G2[as.numeric(revigo_input_G2$classicFisher) < 0.05, ]

# Rename columns for clarity
colnames(sigRes_G2) <- c("GO.ID", "pValue")

# Save as txt to upload to REVIGO
write.table(sigRes_G2, file = "G2topGOsig_for_REVIGO.txt", sep = "\t", row.names = FALSE, quote = FALSE)

### Generate Gen3 ID list for REViGO ###

# Select only the columns REVIGO needs
revigo_input_G3 <- filtered_GO_results_G3[, c("GO.ID", "classicFisher")]

sigRes_G3 <- revigo_input_G3[as.numeric(revigo_input_G3$classicFisher) < 0.05, ]

# Rename columns for clarity
colnames(sigRes_G3) <- c("GO.ID", "pValue")

# Save as txt to upload to REVIGO
write.table(sigRes_G3, file = "G3topGOsig_for_REVIGO.txt", sep = "\t", row.names = FALSE, quote = FALSE)

### Generate Gen4 ID list for REViGO ###

# Select only the columns REVIGO needs
revigo_input_G4 <- filtered_GO_results_G4[, c("GO.ID", "classicFisher")]

sigRes_G4 <- revigo_input_G4[as.numeric(revigo_input_G4$classicFisher) < 0.05, ]

# Rename columns for clarity
colnames(sigRes_G4) <- c("GO.ID", "pValue")

# Save as txt to upload to REVIGO
write.table(sigRes_G4, file = "G4topGOsig_for_REVIGO.txt", sep = "\t", row.names = FALSE, quote = FALSE)
```